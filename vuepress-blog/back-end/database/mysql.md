---
title: MySQL
icon: edit
date: 2022-8-27
category:
  - 数据库
tag:
  - MySQL
---

## having和where区别？

- `where`子句作用于表和视图，`having`作用于组。
- `where`在数据分组前进行过滤，`having`在数据分组后进行过滤。

## MyISAM和InnoDB区别？

- MyISAM：
    1. 只支持表级锁（锁住整张表）；
    2. 不提供事务支持；
    3. 不支持外键；
    4. 不支持数据库异常崩溃后的安全恢复；
- InnoDB：
    1. 支持行级锁和表级锁；
    2. 提供事务支持；
    3. 支持外键；
    4. 支持数据库异常崩溃后的安全恢复；

## 何为 ACID 特性（事务的特性）呢？

  1. 原子性 ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
  2. 一致性： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
  3. 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
  4. 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响；

## 数据库事务的实现原理呢？

- MySQL InnoDB引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。
- MySQL InnoDB引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 `REPEATABLE-READ` ）。
- 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

## 并发事务带来哪些问题?

- 脏读
- 幻读（与不可重复读类似，但是对表中查询的行数上的不一致）
- 不可重复读（某个值不一致）
- 丢失更新

![第一类丢失更新](https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/3_P-6PGQvztA.PNG)

![第二类丢失更新](https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/4_Wo9k0u1K6s.PNG)

![脏读](https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/5_VWqDaFTIUw.PNG)

![不可重复读](https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/6_bBCIMzP68d.PNG)

![幻读](https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/7_3FEp_vn9QH.PNG)

## 事务有哪些隔离级别？

- Read Uncommitted： 读未提交（级别最低）
- Read Committed： 读已提交
- Repeatable Read： 可重复读（默认）
- Serializable： 串行化（级别最高，性能最低，因为要加锁）

![事务隔离级别](https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/8_r3a8a_732R.PNG)

## 数据库范式有哪些？

- 1NF：属性不可再分。
- 2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。
- 3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。

## drop、delete与 truncate 区别？

- drop(丢弃数据): `drop table 表名` ，直接将表都删除掉。—— DDL(数据定义语言，不可回滚)
- truncate (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。  ——DDL(数据定义语言，不可回滚)
- delete（删除数据） : `delete from 表名 where 列名=值`，删除某一列的数据，如果不加 where 子句和`truncate table 表名`作用类似。 ——DML (数据库操作语言`增删改查`，可回滚)

## MySQL中的读有几种？

- 一致性非锁定读（快照读，由MVCC实现）：在`可重复读`和`读已提交`隔离级别下触发，当读取一行值时，这一行刚好正在执行`删除`或`更新`操作时，不会因此去等待行上锁的释放，而是去读取该行版本的最新一个快照（即最新的历史版本）
- 一致性锁定读（当前读）：给行记录加 X （排它锁）或 S （共享锁）
    1. `select...for update`：对记录加 `X` 锁，且其它事务不能加任何锁
    2. `select...lock in share mode`：对记录加 `S` 锁，其它事务也可以加`S`锁，如果加 `x` 锁则会被阻塞

  参考：[https://www.cnblogs.com/cswiki/p/15307265.html](https://www.cnblogs.com/cswiki/p/15307265.html)

## MVCC(多版本并发控制)的实现原理？（重点难点）

- 隐藏字段
    1. `DB_TRX_ID``（6字节）`：记录事务id
    2. `DB_ROLL_PTR``（7字节）`：记录上一个版本数据记录的回滚指针
    3. `DB_ROW_ID``（6字节）`：隐含的自增ID，在没有设置主键的情况下使用该ID产生一个簇拥索引
- Read View（读视图）：快照读操作时生产的读视图
- undo log（回滚日志）
    1. `insert undo log` 
    2. `update undo log`

## 读已提交和可重复读隔离级别下 MVCC 的差异？

  `读已提交(RC)`：总是读取行的最新版本`Read View`；如果行被锁定了，非一致性读不会因此去等待行上锁的释放，而是去读取该行版本的最新一个快照（事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读）

  `可重复读(RR)`：总是读取事务开始时的行数据版本`Read View`
  
## 数据库索引类型有哪些？

  参考：[https://segmentfault.com/a/1190000040177994](https://segmentfault.com/a/1190000040177994)

主键索引：

- 一张数据表有只能有一个主键（可以不设主键），并且主键不能为 null，不能重复
- 若不设主键，如果有唯一索引，则选择该字段为默认的主键，否则会自动创建一个6Byte的自增主键

唯一索引：

- 索引列的值必须唯一，但允许有null，保证该属性数据唯一性
- 一张表允许创建多个唯一索引

普通索引：

- 一张表允许创建多个普通索引，允许数据重复和 NULL
- 唯一作用就是为了快速查询数据

前缀索引：

- 只适用于字符串类型的数据
- 只取文本前几个字符创建索引

全文索引：

- 检索大文本数据中的关键字

## MySQL 聚集索引和非聚集索引区别？

聚集索引：索引结构和数据一起存放的索引，是一种数据存储方式。主键索引属于聚集索引。

非聚集索引：二级索引（唯一索引，普通索引，前缀索引等）属于非聚集索引。

相同点:  

- 内部都是 B+ 树

不同点：

- 聚集索引的叶子节点存放是一整行数据（数据、索引放一块）；非聚集索引的叶子节点存储主键的值
- 聚集索引一个表只能有一个；非聚集索引一个表可以存在多个
- 聚集索引存储记录是物理上连续存在；非聚集索引是逻辑上的连续
- 聚集索引查询数据速度快，插入数据速度慢；非聚集索引反之，可能会二次查询（回表）

## 非聚集索引一定回表查询吗(覆盖索引)?

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。

覆盖索引：需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询（概括：查询的正好是索引—主键索引、唯一索引、普通索引等）

`如：select id from table where id = 1`

## 索引的优缺点

优点 ：

- 使用索引可以加快数据的检索速度（大大减少检索的数据量）
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

缺点 ：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

## B树和B+树的区别？

注意：MySQL默认使用B+树

- B 树的所有节点既存放键(key) 也存放 数据(data)；而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
- B 树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

![B+树](https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/1.PNG)
